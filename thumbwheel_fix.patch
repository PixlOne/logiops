
@@ -1,48 +1,50 @@
 /*
  * Copyright 2019-2023 PixlOne
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include <features/ThumbWheel.h>
 #include <actions/gesture/AxisGesture.h>
 #include <Device.h>
+#include <InputDevice.h>
 #include <util/log.h>
 #include <ipc_defs.h>
+#include <cmath>
 
 using namespace logid::features;
 using namespace logid::backend;
 using namespace logid;
 
 #define FLAG_STR(b) (_wheel_info.capabilities & _thumb_wheel->b ? "YES" : "NO")
 
 namespace {
     std::shared_ptr<actions::Action> _genAction(
             Device* dev, std::optional<config::BasicAction>& conf,
             const std::shared_ptr<ipcgull::node>& parent) {
         if (conf.has_value()) {
             try {
                 return actions::Action::makeAction(dev, conf.value(), parent);
             } catch (actions::InvalidAction& e) {
                 logPrintf(WARN, "Mapping thumb wheel to invalid action");
             }
         }
 
         return nullptr;
     }
 
     std::shared_ptr<actions::Gesture> _genGesture(
             Device* dev, std::optional<config::Gesture>& conf,
             const std::shared_ptr<ipcgull::node>& parent, const std::string& direction) {

@@ -181,74 +183,108 @@ void ThumbWheel::_handleEvent(hidpp20::ThumbWheel::ThumbwheelEvent event) {
     }
 
     if (event.rotationStatus != hidpp20::ThumbWheel::Inactive) {
         // Make right positive unless inverted
         event.rotation *= _wheel_info.defaultDirection;
 
         if (event.rotationStatus == hidpp20::ThumbWheel::Start) {
             if (_right_gesture)
                 _right_gesture->press(true);
             if (_left_gesture)
                 _left_gesture->press(true);
         }
 
         if (event.rotation) {
             int8_t direction = event.rotation > 0 ? 1 : -1;
             std::shared_ptr<actions::Gesture> scroll_action;
 
             if (direction > 0)
                 scroll_action = _right_gesture;
             else
                 scroll_action = _left_gesture;
 
             if (scroll_action) {
                 scroll_action->press(true);
                 scroll_action->move((int16_t) (direction * event.rotation));
+            } else {
+                _fallbackScroll(direction * event.rotation);
             }
         }
 
         if (event.rotationStatus == hidpp20::ThumbWheel::Stop) {
             if (_right_gesture)
                 _right_gesture->release(false);
             if (_left_gesture)
                 _left_gesture->release(false);
         }
     }
 }
 
 void ThumbWheel::_fixGesture(const std::shared_ptr<actions::Gesture>& gesture) const {
     try {
         auto axis = std::dynamic_pointer_cast<actions::AxisGesture>(gesture);
         // TODO: How do hires multipliers work on 0x2150 thumbwheels?
         if (axis)
             axis->setHiresMultiplier(_wheel_info.divertedRes);
     } catch (std::bad_cast& e) {}
 
     if (gesture)
         gesture->press(true);
 }
 
+void ThumbWheel::_initFallbackAxis() {
+    if (_fallback_axis.has_value())
+        return;
+
+    try {
+        auto axis = _device->virtualInput()->toAxisCode("REL_HWHEEL_HI_RES");
+        _device->virtualInput()->registerAxis(axis);
+        _fallback_axis = axis;
+    } catch (const std::exception&) {
+        try {
+            auto axis = _device->virtualInput()->toAxisCode("REL_HWHEEL");
+            _device->virtualInput()->registerAxis(axis);
+            _fallback_axis = axis;
+        } catch (const std::exception&) {
+            _fallback_axis.reset();
+        }
+    }
+}
+
+void ThumbWheel::_fallbackScroll(double delta) {
+    _initFallbackAxis();
+    if (!_fallback_axis.has_value())
+        return;
+
+    _fallback_remainder += delta;
+    int movement = (int) std::trunc(_fallback_remainder);
+    if (movement != 0) {
+        _device->virtualInput()->moveAxis(_fallback_axis.value(), movement);
+        _fallback_remainder -= movement;
+    }
+}
+
 ThumbWheel::IPC::IPC(ThumbWheel* parent) : ipcgull::interface(
         SERVICE_ROOT_NAME ".ThumbWheel", {
                 {"GetConfig", {this, &IPC::getConfig, {"divert", "invert"}}},
                 {"SetDivert", {this, &IPC::setDivert, {"divert"}}},
                 {"SetInvert", {this, &IPC::setInvert, {"invert"}}},
                 {"SetLeft",   {this, &IPC::setLeft,   {"type"}}},
                 {"SetRight",  {this, &IPC::setRight,  {"type"}}},
                 {"SetProxy",  {this, &IPC::setProxy,  {"type"}}},
                 {"SetTap",    {this, &IPC::setTap,    {"type"}}},
                 {"SetTouch",  {this, &IPC::setTouch,  {"type"}}},
         }, {}, {}), _parent(*parent) {
 }
 
 config::ThumbWheel& ThumbWheel::IPC::_parentConfig() {
     auto& config = _parent._config.get();
     if (!config.has_value()) {
         config.emplace();
     }
 
     return config.value();
 }
 
 std::tuple<bool, bool> ThumbWheel::IPC::getConfig() const {
     std::shared_lock lock(_parent._config_mutex);
 
 

@@ -1,98 +1,106 @@
 /*
  * Copyright 2019-2023 PixlOne
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #ifndef LOGID_FEATURE_THUMBWHEEL_H
 #define LOGID_FEATURE_THUMBWHEEL_H
 
 #include <features/DeviceFeature.h>
 #include <actions/gesture/Gesture.h>
 #include <backend/hidpp20/features/ThumbWheel.h>
 #include <backend/hidpp/Device.h>
+#include <optional>
 
 namespace logid::features {
     class ThumbWheel : public DeviceFeature {
     public:
         explicit ThumbWheel(Device* dev);
 
         void configure() final;
 
         void listen() final;
 
         void setProfile(config::Profile& profile) final;
 
     private:
         void _makeConfig();
 
         void _handleEvent(backend::hidpp20::ThumbWheel::ThumbwheelEvent event);
 
+        void _initFallbackAxis();
+        void _fallbackScroll(double delta);
+
         void _fixGesture(const std::shared_ptr<actions::Gesture>& gesture) const;
 
         class IPC : public ipcgull::interface {
         public:
             explicit IPC(ThumbWheel* parent);
 
             [[nodiscard]] std::tuple<bool, bool> getConfig() const;
 
             void setDivert(bool divert);
 
             void setInvert(bool invert);
 
             void setLeft(const std::string& type);
 
             void setRight(const std::string& type);
 
             void setProxy(const std::string& type);
 
             void setTap(const std::string& type);
 
             void setTouch(const std::string& type);
 
         private:
             config::ThumbWheel& _parentConfig();
 
             ThumbWheel& _parent;
         };
 
         std::shared_ptr<backend::hidpp20::ThumbWheel> _thumb_wheel;
         backend::hidpp20::ThumbWheel::ThumbwheelInfo _wheel_info;
 
         std::shared_ptr<ipcgull::node> _node;
 
         std::shared_ptr<actions::Gesture> _left_gesture;
         std::shared_ptr<ipcgull::node> _left_node;
         std::shared_ptr<actions::Gesture> _right_gesture;
         std::shared_ptr<ipcgull::node> _right_node;
         std::shared_ptr<actions::Action> _proxy_action;
         std::shared_ptr<ipcgull::node> _proxy_node;
         std::shared_ptr<actions::Action> _tap_action;
         std::shared_ptr<ipcgull::node> _tap_node;
         std::shared_ptr<actions::Action> _touch_action;
         std::shared_ptr<ipcgull::node> _touch_node;
 
         bool _last_proxy = false;
         bool _last_touch = false;
 
+        // Fallback axis handling when no gesture is configured
+        std::optional<uint> _fallback_axis;
+        double _fallback_remainder = 0.0;
+
         mutable std::shared_mutex _config_mutex;
         std::reference_wrapper<std::optional<config::ThumbWheel>> _config;
 
         EventHandlerLock<backend::hidpp::Device> _ev_handler;
 
         std::shared_ptr<IPC> _ipc_interface;
     };
 }
 

)